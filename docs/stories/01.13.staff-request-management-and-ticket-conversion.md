# Story 1.13: Staff Request Management and Ticket Conversion

**Epic:** EPIC-01 - Service Center Phase 2 - Workflow, Warranty & Warehouse
**Story ID:** SC-PHASE2-01.13
**Created:** 2025-10-23
**Status:** ✅ Complete
**Completed:** 2025-10-25 (Verified via code review)
**Depends On:** Story 1.12 (Service Request Tracking)

---

## Story

**As a** reception staff member,
**I want** to review incoming service requests and convert them to service tickets,
**so that** online requests are integrated into our existing workflow.

---

## Acceptance Criteria

1. Create tRPC procedures (authenticated):
   - `serviceRequest.listPending` - List requests in 'submitted'/'received' status
   - `serviceRequest.getDetails` - Get full request details
   - `serviceRequest.updateStatus` - Update request status (received/processing)
   - `serviceRequest.convertToTicket` - Create ticket from request
   - `serviceRequest.reject` - Reject request with reason
2. Build staff request queue at `/dashboard/service-requests`
3. Queue shows: tracking token, customer name, product, serial, submitted date, status
4. Quick actions: View Details, Accept, Reject
5. Request detail modal shows all information including problem description
6. Convert to ticket: pre-populate ticket form with request data
7. Auto-link: set request.ticket_id when ticket created, update status to 'processing'
8. Rejection workflow: require rejection reason, send notification (Story 1.15)
9. Filter requests by status (submitted, received, processing)
10. Search by tracking token, customer name, or serial number
11. Badge counter showing pending requests in sidebar navigation

---

## Integration Verification

- **IV1**: Converting request to ticket follows existing ticket creation workflow
- **IV2**: Linked tickets appear in normal ticket list with indicator
- **IV3**: Request queue does not interfere with walk-in ticket creation
- **IV4**: Request-to-ticket conversion triggers normal task generation (Story 1.3)

---

## Tasks / Subtasks

### Backend Tasks

- [ ] Create authenticated request procedures (AC: 1)
  - [ ] Extend `src/server/routers/service-request.ts` (staff router)
  - [ ] Implement `serviceRequest.listPending` with pagination
  - [ ] Implement `serviceRequest.getDetails` procedure
  - [ ] Implement `serviceRequest.updateStatus` procedure
  - [ ] Implement `serviceRequest.convertToTicket` procedure
  - [ ] Implement `serviceRequest.reject` procedure

- [ ] Implement ticket conversion logic (AC: 6, 7)
  - [ ] Extract customer info from request
  - [ ] Find or create customer record
  - [ ] Create service ticket with request data
  - [ ] Link ticket to request (set ticket_id)
  - [ ] Update request status to 'processing'
  - [ ] Copy problem description to ticket notes

- [ ] Add rejection workflow (AC: 8)
  - [ ] Require cancellation_reason field
  - [ ] Set request status to 'cancelled'
  - [ ] Store cancellation_reason, reviewed_by_id, and reviewed_at
  - [ ] Prepare for email notification (implemented in Story 1.15)

- [ ] Add search and filter support (AC: 9, 10)
  - [ ] Filter by status
  - [ ] Search by tracking_token
  - [ ] Search by customer_name (ILIKE)
  - [ ] Search by serial_number

### Frontend Tasks

- [ ] Create service request types
  - [ ] Extend `src/types/service-request.ts`
  - [ ] StaffServiceRequest interface (full details)
  - [ ] RequestFilter interface

- [ ] Create service request hooks
  - [ ] Extend `src/hooks/use-service-requests.ts`
  - [ ] `usePendingRequests()` hook with filters
  - [ ] `useRequestDetails()` hook
  - [ ] `useUpdateRequestStatus()` mutation hook
  - [ ] `useConvertToTicket()` mutation hook
  - [ ] `useRejectRequest()` mutation hook
  - [ ] `usePendingCount()` hook for badge

- [ ] Build request queue page (AC: 2, 3)
  - [ ] Create `/dashboard/service-requests` route
  - [ ] Create `ServiceRequestsTable` component in `src/components/tables/`
  - [ ] Show: tracking token, customer, product, serial, date, status
  - [ ] Actions: View, Accept, Reject
  - [ ] Filters: status dropdown
  - [ ] Search input

- [ ] Build request detail modal (AC: 5)
  - [ ] Create `RequestDetailModal` component in `src/components/modals/`
  - [ ] Display all request information
  - [ ] Show product and warranty details
  - [ ] Show customer contact information
  - [ ] Show problem description (full text)
  - [ ] Actions: Convert to Ticket, Reject, Update Status

- [ ] Implement ticket conversion (AC: 6, 7)
  - [ ] Create `ConvertToTicketModal` component
  - [ ] Pre-populate ticket form with:
    - Customer name, email, phone
    - Product (from request)
    - Serial number
    - Problem description → initial comment
    - Preferred delivery method
  - [ ] Allow staff to edit before creating
  - [ ] Submit ticket creation
  - [ ] Show success message with ticket number

- [ ] Build rejection modal (AC: 8)
  - [ ] Create `RejectRequestModal` component
  - [ ] Rejection reason textarea (required)
  - [ ] Common rejection reasons dropdown
  - [ ] Confirm button
  - [ ] Show warning about customer notification

- [ ] Add pending badge to navigation (AC: 11)
  - [ ] Query pending count
  - [ ] Display badge on "Service Requests" menu item
  - [ ] Update count in real-time (30s interval)

- [ ] Create status filter UI (AC: 9)
  - [ ] Status dropdown: All, Submitted, Received, Processing
  - [ ] Apply filter to query

- [ ] Implement search (AC: 10)
  - [ ] Search input with debounce
  - [ ] Search across token, customer name, serial
  - [ ] Clear search button

### Integration & Testing Tasks

- [ ] Test ticket creation workflow (IV1)
  - [ ] Convert request to ticket
  - [ ] Verify normal ticket creation flow
  - [ ] Verify all ticket features work

- [ ] Test ticket list display (IV2)
  - [ ] View ticket list
  - [ ] Verify converted tickets visible
  - [ ] Verify indicator shows origin

- [ ] Test walk-in ticket creation (IV3)
  - [ ] Create walk-in ticket
  - [ ] Create request ticket
  - [ ] Verify both workflows work independently

- [ ] Test task generation (IV4)
  - [ ] Convert request to ticket
  - [ ] Verify tasks auto-generated (if template exists)
  - [ ] Verify task generation trigger fires

---

## Dev Notes

### tRPC Staff Request Procedures

```typescript
// src/server/routers/service-request.ts (extend existing, add staff procedures)

// Staff procedures (authenticated)
listPending: publicProcedure
  .input(z.object({
    status: z.enum(['submitted', 'received', 'processing']).optional(),
    search: z.string().optional(),
    limit: z.number().min(1).max(100).default(50),
    offset: z.number().min(0).default(0)
  }))
  .query(async ({ ctx, input }) => {
    if (!ctx.user || !['admin', 'manager', 'reception'].includes(ctx.user.role)) {
      throw new TRPCError({ code: 'FORBIDDEN' });
    }

    let query = ctx.supabaseAdmin
      .from('service_requests')
      .select(`
        *,
        product:products(name, brand:brands(name)),
        physical_product:physical_products(serial_number, warranty_end_date),
        linked_ticket:service_tickets(ticket_number, status)
      `, { count: 'exact' });

    // Status filter
    if (input.status) {
      query = query.eq('status', input.status);
    } else {
      query = query.in('status', ['submitted', 'received', 'processing']);
    }

    // Search
    if (input.search) {
      query = query.or(`
        tracking_token.ilike.%${input.search}%,
        customer_name.ilike.%${input.search}%,
        serial_number.ilike.%${input.search}%
      `);
    }

    const { data, error, count } = await query
      .order('submitted_at', { ascending: false })
      .range(input.offset, input.offset + input.limit - 1);

    if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });

    return {
      requests: data || [],
      total: count || 0
    };
  }),

getDetails: publicProcedure
  .input(z.object({ request_id: z.string().uuid() }))
  .query(async ({ ctx, input }) => {
    if (!ctx.user || !['admin', 'manager', 'reception'].includes(ctx.user.role)) {
      throw new TRPCError({ code: 'FORBIDDEN' });
    }

    const { data, error } = await ctx.supabaseAdmin
      .from('service_requests')
      .select(`
        *,
        product:products(*,brand:brands(*)),
        physical_product:physical_products(*),
        linked_ticket:service_tickets(*)
      `)
      .eq('id', input.request_id)
      .single();

    if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });

    return data;
  }),

updateStatus: publicProcedure
  .input(z.object({
    request_id: z.string().uuid(),
    status: z.enum(['received', 'processing'])
  }))
  .mutation(async ({ ctx, input }) => {
    if (!ctx.user || !['admin', 'manager', 'reception'].includes(ctx.user.role)) {
      throw new TRPCError({ code: 'FORBIDDEN' });
    }

    const updateData: any = {
      status: input.status
    };

    if (input.status === 'received') {
      updateData.received_at = new Date().toISOString();
    } else if (input.status === 'processing') {
      updateData.processing_started_at = new Date().toISOString();
    }

    const { data, error } = await ctx.supabaseAdmin
      .from('service_requests')
      .update(updateData)
      .eq('id', input.request_id)
      .select()
      .single();

    if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });

    return data;
  }),

convertToTicket: publicProcedure
  .input(z.object({
    request_id: z.string().uuid(),
    // Allow staff to override auto-populated data
    customer_id: z.string().uuid().optional(),
    service_type: z.enum(['warranty', 'paid']),
    priority: z.enum(['low', 'normal', 'high']).default('normal'),
    additional_notes: z.string().optional()
  }))
  .mutation(async ({ ctx, input }) => {
    if (!ctx.user || !['admin', 'manager', 'reception'].includes(ctx.user.role)) {
      throw new TRPCError({ code: 'FORBIDDEN' });
    }

    // Get request details
    const { data: request } = await ctx.supabaseAdmin
      .from('service_requests')
      .select(`
        *,
        physical_product:physical_products(product_id)
      `)
      .eq('id', input.request_id)
      .single();

    if (!request) {
      throw new TRPCError({ code: 'NOT_FOUND', message: 'Request not found' });
    }

    // Find or create customer
    let customerId = input.customer_id;

    if (!customerId) {
      // Try to find existing customer by email
      const { data: existingCustomer } = await ctx.supabaseAdmin
        .from('customers')
        .select('id')
        .eq('email', request.customer_email)
        .single();

      if (existingCustomer) {
        customerId = existingCustomer.id;
      } else {
        // Create new customer
        const { data: newCustomer, error: customerError } = await ctx.supabaseAdmin
          .from('customers')
          .insert({
            name: request.customer_name,
            email: request.customer_email,
            phone: request.customer_phone,
            created_by_id: ctx.user.id
          })
          .select()
          .single();

        if (customerError) {
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: customerError.message });
        }

        customerId = newCustomer.id;
      }
    }

    // Create service ticket
    const { data: ticket, error: ticketError } = await ctx.supabaseAdmin
      .from('service_tickets')
      .insert({
        customer_id: customerId,
        product_id: request.physical_product.product_id,
        serial_number: request.serial_number,
        service_type: input.service_type,
        priority: input.priority,
        status: 'pending',
        problem_description: request.problem_description,
        preferred_delivery_method: request.preferred_delivery_method,
        delivery_address: request.delivery_address,
        created_by_id: ctx.user.id,
        request_id: request.id // Link to request
      })
      .select()
      .single();

    if (ticketError) {
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: ticketError.message });
    }

    // Add initial comment with request details
    await ctx.supabaseAdmin
      .from('service_ticket_comments')
      .insert({
        ticket_id: ticket.id,
        comment: `Converted from service request ${request.tracking_token}\n\nCustomer's problem description:\n${request.problem_description}${input.additional_notes ? `\n\nStaff notes:\n${input.additional_notes}` : ''}`,
        created_by_id: ctx.user.id
      });

    // Update request with ticket link
    await ctx.supabaseAdmin
      .from('service_requests')
      .update({
        ticket_id: ticket.id,
        status: 'processing',
        processing_started_at: new Date().toISOString()
      })
      .eq('id', input.request_id);

    return {
      success: true,
      ticket
    };
  }),

reject: publicProcedure
  .input(z.object({
    request_id: z.string().uuid(),
    cancellation_reason: z.string().min(10)
  }))
  .mutation(async ({ ctx, input }) => {
    if (!ctx.user || !['admin', 'manager', 'reception'].includes(ctx.user.role)) {
      throw new TRPCError({ code: 'FORBIDDEN' });
    }

    const { data, error } = await ctx.supabaseAdmin
      .from('service_requests')
      .update({
        status: 'cancelled',
        cancellation_reason: input.cancellation_reason,
        reviewed_by_id: ctx.user.id,
        reviewed_at: new Date().toISOString()
      })
      .eq('id', input.request_id)
      .select()
      .single();

    if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });

    // Email notification will be handled by Story 1.15

    return data;
  }),

getPendingCount: publicProcedure
  .query(async ({ ctx }) => {
    if (!ctx.user) throw new TRPCError({ code: 'UNAUTHORIZED' });

    const { count } = await ctx.supabaseAdmin
      .from('service_requests')
      .select('id', { count: 'exact', head: true })
      .in('status', ['submitted', 'received']);

    return count || 0;
  })
```

### Service Requests Page

```typescript
// app/(auth)/dashboard/service-requests/page.tsx

'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { ServiceRequestsTable } from '@/components/tables/service-requests-table';
import { usePendingRequests } from '@/hooks/use-service-requests';
import { useDebounce } from '@/hooks/use-debounce';
import { Search } from 'lucide-react';

export default function ServiceRequestsPage() {
  const [statusFilter, setStatusFilter] = useState<string | undefined>(undefined);
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearch = useDebounce(searchTerm, 500);

  const { data, isLoading } = usePendingRequests({
    status: statusFilter,
    search: debouncedSearch
  });

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold">Service Requests</h1>
          <p className="text-muted-foreground">
            Review and convert online service requests to tickets
          </p>
        </div>
      </div>

      <div className="flex gap-4">
        <div className="flex-1 relative">
          <Search className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search by token, customer name, or serial..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="pl-10"
          />
        </div>

        <Select value={statusFilter || 'all'} onValueChange={(v) => setStatusFilter(v === 'all' ? undefined : v)}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Filter by status" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Requests</SelectItem>
            <SelectItem value="submitted">Submitted</SelectItem>
            <SelectItem value="received">Received</SelectItem>
            <SelectItem value="processing">Processing</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <ServiceRequestsTable
        requests={data?.requests || []}
        isLoading={isLoading}
      />
    </div>
  );
}
```

### Testing

**Testing Standards:**
- Follow `docs/architecture/09-testing-strategy.md` when tests are implemented
- Manual testing required for this story

**This Story Testing:**
- **Manual request queue** viewing
- **Manual request-to-ticket conversion** testing
- **Manual rejection workflow** testing
- **Manual search and filter** testing
- **Manual verification** of IV1-IV4

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation | John (PM) |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation*

---

## QA Results

*This section will be populated by the QA agent after implementation review*
