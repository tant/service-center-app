/**
 * Public Service Request API Route
 *
 * Allows unauthenticated users to submit service requests
 * Protected by rate limiting
 */

import { type NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { rateLimitPublicEndpoint } from "@/middleware/rateLimit";
import { createClient } from "@/utils/supabase/server";

// Request validation schema
const serviceRequestSchema = z.object({
  customer_name: z.string().min(2, "Tên phải có ít nhất 2 ký tự"),
  customer_phone: z
    .string()
    .regex(/^0[0-9]{9}$/, "Số điện thoại phải bắt đầu bằng 0 và có 10 chữ số"),
  customer_email: z.string().email("Email không hợp lệ").optional(),
  device_type: z.string().min(2, "Loại thiết bị là bắt buộc"),
  issue_description: z
    .string()
    .min(10, "Mô tả vấn đề phải có ít nhất 10 ký tự"),
});

export async function POST(request: NextRequest) {
  try {
    // ⚠️ RATE LIMITING - Check before processing
    const rateLimitResponse = rateLimitPublicEndpoint(request);
    if (rateLimitResponse.status === 429) {
      return rateLimitResponse;
    }

    // Parse and validate request body
    const body = await request.json();
    const validatedData = serviceRequestSchema.parse(body);

    // Create Supabase client (server-side, no auth required for public endpoint)
    const supabase = await createClient();

    // Insert service request
    const { data: serviceRequest, error } = await supabase
      .from("service_requests")
      .insert({
        customer_name: validatedData.customer_name,
        customer_phone: validatedData.customer_phone,
        customer_email: validatedData.customer_email || null,
        device_type: validatedData.device_type,
        issue_description: validatedData.issue_description,
        status: "pending",
        // tracking_token is auto-generated by database trigger
      })
      .select("id, tracking_token")
      .single();

    if (error) {
      console.error("Error creating service request:", error);
      return NextResponse.json(
        {
          error: "Database Error",
          message: "Không thể tạo yêu cầu dịch vụ. Vui lòng thử lại.",
        },
        { status: 500 },
      );
    }

    // Success response with tracking token
    return NextResponse.json(
      {
        success: true,
        message:
          "Yêu cầu dịch vụ của bạn đã được gửi thành công. Vui lòng lưu mã theo dõi để kiểm tra trạng thái.",
        tracking_token: serviceRequest.tracking_token,
        request_id: serviceRequest.id,
      },
      {
        status: 201,
        headers: rateLimitResponse.headers as HeadersInit,
      },
    );
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          error: "Validation Error",
          message: "Dữ liệu không hợp lệ",
          errors: error.issues,
        },
        { status: 400 },
      );
    }

    console.error("Unexpected error:", error);
    return NextResponse.json(
      {
        error: "Internal Server Error",
        message: "Đã xảy ra lỗi. Vui lòng thử lại sau.",
      },
      { status: 500 },
    );
  }
}

// GET method for tracking requests
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const trackingToken = searchParams.get("token");

    if (!trackingToken) {
      return NextResponse.json(
        { error: "Missing tracking token" },
        { status: 400 },
      );
    }

    const supabase = await createClient();

    const { data: serviceRequest, error } = await supabase
      .from("service_requests")
      .select("id, customer_name, device_type, status, created_at")
      .eq("tracking_token", trackingToken)
      .single();

    if (error || !serviceRequest) {
      return NextResponse.json(
        { error: "Request not found", message: "Không tìm thấy yêu cầu" },
        { status: 404 },
      );
    }

    return NextResponse.json({
      success: true,
      request: serviceRequest,
    });
  } catch (error) {
    console.error("Error fetching service request:", error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 },
    );
  }
}
